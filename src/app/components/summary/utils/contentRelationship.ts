// Utilities for establishing and visualizing relationships between content

// Types for source references
export interface SourceReference {
  id: string;
  sourceId: string;
  targetId: string;
  sourceText: string;
  startPosition: number;
  endPosition: number;
  confidence: number;
}

// Map of keypoint IDs to source references
export type SourceReferenceMap = {
  [keypointId: string]: SourceReference[];
};

// Generate citation data based on content
export const generateCitations = (
  originalText: string, 
  keyPoints: any[]
): SourceReferenceMap => {
  // This is a simplified implementation
  // In a real app, these would be generated by the AI model
  const referenceMap: SourceReferenceMap = {};
  
  // For each key point, find potential source references in the original text
  keyPoints.forEach(keyPoint => {
    const keyPointWords = keyPoint.text
      .toLowerCase()
      .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "")
      .split(/\s+/)
      .filter((word: string) => word.length > 4);
    
    const references: SourceReference[] = [];
    
    // For demo purposes, find matches of the longest words in the key point
    if (keyPointWords.length > 0) {
      // Sort by length descending to find longest words first
      const sortedWords = [...keyPointWords].sort((a, b) => b.length - a.length);
      
      // Take up to 3 longest words to search for
      const searchWords = sortedWords.slice(0, 3);
      
      searchWords.forEach(word => {
        const wordRegex = new RegExp(`\\b${word}\\b`, 'i');
        const match = originalText.match(wordRegex);
        
        if (match && match.index !== undefined) {
          const startPosition = match.index;
          const endPosition = startPosition + match[0].length;
          
          // Extract a bit of context around the match
          const contextStart = Math.max(0, startPosition - 40);
          const contextEnd = Math.min(originalText.length, endPosition + 40);
          const sourceText = originalText.substring(contextStart, contextEnd);
          
          references.push({
            id: `ref-${keyPoint.id}-${references.length}`,
            sourceId: 'original-text',
            targetId: keyPoint.id,
            sourceText,
            startPosition,
            endPosition,
            confidence: keyPoint.confidence * 0.9 // Slightly lower than keypoint confidence
          });
        }
      });
    }
    
    if (references.length > 0) {
      referenceMap[keyPoint.id] = references;
    }
  });
  
  return referenceMap;
};

// Highlight related content when hovering over a keypoint
export const highlightRelatedContent = (
  keypointId: string, 
  sourceRefs: SourceReferenceMap,
  highlight: boolean = true
) => {
  // Clear any existing highlights
  document.querySelectorAll('.source-highlight').forEach(el => {
    el.classList.remove('source-highlight');
    el.setAttribute('aria-selected', 'false');
  });
  
  if (!highlight) return;

  const references = sourceRefs[keypointId];
  if (!references || references.length === 0) return;
  
  // Add highlights to source references
  references.forEach(ref => {
    const sourceEl = document.getElementById(`source-text-${ref.startPosition}-${ref.endPosition}`);
    if (sourceEl) {
      sourceEl.classList.add('source-highlight');
      sourceEl.setAttribute('aria-selected', 'true');
      
      // Scroll the element into view if needed
      sourceEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  });
};

// Create a visual pattern based on the category and confidence
export const getVisualPattern = (category: string, confidence: number) => {
  const patterns = {
    concept: {
      pattern: 'linear-gradient(45deg, rgba(59, 130, 246, 0.1) 25%, transparent 25%, transparent 50%, rgba(59, 130, 246, 0.1) 50%, rgba(59, 130, 246, 0.1) 75%, transparent 75%, transparent)',
      size: '10px 10px'
    },
    fact: {
      pattern: 'linear-gradient(45deg, rgba(20, 184, 166, 0.1) 25%, transparent 25%, transparent 50%, rgba(20, 184, 166, 0.1) 50%, rgba(20, 184, 166, 0.1) 75%, transparent 75%, transparent)',
      size: '10px 10px'
    },
    definition: {
      pattern: 'linear-gradient(45deg, rgba(139, 92, 246, 0.1) 25%, transparent 25%, transparent 50%, rgba(139, 92, 246, 0.1) 50%, rgba(139, 92, 246, 0.1) 75%, transparent 75%, transparent)',
      size: '10px 10px'
    },
    person: {
      pattern: 'linear-gradient(45deg, rgba(34, 197, 94, 0.1) 25%, transparent 25%, transparent 50%, rgba(34, 197, 94, 0.1) 50%, rgba(34, 197, 94, 0.1) 75%, transparent 75%, transparent)',
      size: '10px 10px'
    },
    date: {
      pattern: 'linear-gradient(45deg, rgba(234, 179, 8, 0.1) 25%, transparent 25%, transparent 50%, rgba(234, 179, 8, 0.1) 50%, rgba(234, 179, 8, 0.1) 75%, transparent 75%, transparent)',
      size: '10px 10px'
    },
    formula: {
      pattern: 'linear-gradient(45deg, rgba(239, 68, 68, 0.1) 25%, transparent 25%, transparent 50%, rgba(239, 68, 68, 0.1) 50%, rgba(239, 68, 68, 0.1) 75%, transparent 75%, transparent)',
      size: '10px 10px'
    }
  };
  
  // Adjust opacity based on confidence
  const basePattern = patterns[category as keyof typeof patterns] || patterns.fact;
  const opacity = 0.3 + (confidence * 0.7); // Scale opacity from 0.3 to 1.0 based on confidence
  
  return {
    backgroundImage: basePattern.pattern.replace(/0\.1/g, opacity.toString()),
    backgroundSize: basePattern.size
  };
};
